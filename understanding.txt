SeqOneByteString: The simplest, contains a few header fields and then the string's bytes (not UTF-8 encoded, can only contain characters in the first 256 unicode code points)
SeqTwoByteString: Same, but uses two bytes for each character (using surrogate pairs to represent unicode characters that can't be represented in two bytes).
SlicedString: A substring of some other string. Contains a pointer to the "parent" string and an offset and length.
ConsString: The result of adding two strings (if over a certain size). Contains pointers to both strings (which may themselves be any of these types of strings).
ExternalString: Used for strings that have been passed in from outside of V8.


All these have a common parent class String,
HeapObject has one field: the pointer to its Map
Name adds one additional field: a hash value.
String adds another field: the length.

On a 64-bit system, each one is 8 bytes.


0:  map (string type)
4:  length (in characters)
8:  hash code (lazily computed)
12:  characters...



// TaintTracking
datatypes:
TaintFlag; //uint32_t
TaintData; // uint_8_t

// in v8/include/v8.h
TaintType;
// TaintType, 0~20 , 32-224: encoding types 
// (this is the 8 bits used for taint propagating);

  enum TaintType {
    UNTAINTED = 0,
    TAINTED = 1,
    COOKIE = 2,
    MESSAGE = 3,
    URL = 4,
    URL_HASH = 5,
    URL_PROTOCOL = 6,
    URL_HOST = 7,
    URL_HOSTNAME = 8,
    URL_ORIGIN = 9,
    URL_PORT = 10,
    URL_PATHNAME = 11,
    URL_SEARCH = 12,
    DOM = 13,
    REFERRER = 14,
    WINDOWNAME = 15,
    STORAGE = 16,
    NETWORK = 17,
    MULTIPLE_TAINTS = 18,       // Used when combining multiple bytes with
                                // different taints.
    MESSAGE_ORIGIN = 19,

    // This must be less than the value of URL_ENCODED
    MAX_TAINT_TYPE = 20,

    // Encoding types
    URL_ENCODED = 32,            // 1 << 5
    URL_COMPONENT_ENCODED = 64,  // 2 << 5
    ESCAPE_ENCODED = 96,         // 3 << 5
    MULTIPLE_ENCODINGS = 128,    // 4 << 5
    URL_DECODED = 160,           // 5 << 5
    URL_COMPONENT_DECODED = 192, // 6 << 5
    ESCAPE_DECODED = 224,        // 7 << 5

    NO_ENCODING = 0,            // Must use the encoding mask to compare to no
                                // encoding.

    // Masks
    TAINT_TYPE_MASK = 31,       // 1 << 5 - 1 (all ones in lower 5 bits)
    ENCODING_TYPE_MASK = 224   // 7 << 5 (all ones in top 3 bits)
  };


  
class TaintTracker
    class Impl;

    RegisterTaintListener: implementedin Impl
    
    static TaintTracker* FromIsolate
    static TaintTracker* New


class TaintListener


class MessageHolder;
class TaintVisitor;
    void run(T* source, int start, int len);
        VisitIntoStringTemplate
            DoVisit(source->GetChars(), StringTaintData(source), from, len);
                Visit(visitee, taint_info, offset, size);
                    segments_.push_back((visitee + offset, true, size));
    StringTaintData(str)
        return str->GetTaintChars();
    std::vector<std::tuple<String*, int, int>> visitee_stack_; 
    //source, start, len
    String* visitee_;
    bool writeable_;

class CopyVisitor : public TaintVisitor

class StringCopier : public TaintVisitor
    void Visit
    void Build
    std::vector<std::tuple<const uint8_t*, bool, int>> segments_; 
    //(visitee + offset, true, size)

class CopyVisitor : public TaintVisitor;

TaintType GetTaintStatus();



// taint_tracking-inl.h
class MessageHolder





// ast_serialization.cc
// This file defines how to serialize ASTs to the log file during symbolic
// execution.
// just ignore these files?
// need to remove build files...bla bla, not that easy?

seems to be dealing with AST node types
what job do Handle*** functions do?



FunctionLiteral
syntax_kind, kind, scope


a lot of type conversion errors



change the paras of OnNewConcatStringCopy to Handles


InitTaintData 


InitTaintSeqByteString


ObjectPropertySymbolicStateManager



now the passing of String paras



change GetWriteableStringTaintData to String!
StringTaintData
StringTaintData_TryAllocate


FlattenTaint
ConcatTaint


change VisitIntoStringTemplate to String!
change SetTaintStatus to String!
change FlattenTaintData to String!
OnNewDeserializedString

  MarkNewString(source);
  OnNewStringLiteral(source);



InitTaintSeqByteString


CopyJsStringSlow
OnNewStringLiteral
OnNewConcatStringCopy


visitee_stack_ 里面用什么格式？
string*, int, int


FlattenTaint
ConcatTaint

GetTaintStatusRange

CheckTaintError

OnNewSubStringCopy

can we change Stirng to String & ?
先不管

加了三个global函数
GlobalPrintToTaintLog
GlobalSetTaint
GlobalTaintConstants


GenerateTaintTrackingHook

JsonParser
internal variables:
  
  Isolate* isolate_;
  const uint64_t hash_seed_;
  JsonToken next_;
  // Indicates whether the bytes underneath source_ can relocate during GC.
  bool chars_may_relocate_;
  Handle<JSFunction> object_constructor_;
  const Handle<String> original_source_;
  Handle<String> source_;
  
  const Char* cursor_;
  const Char* end_;
  const Char* chars_;




ParseJson is the function to parse json string

ParseJson()
    ParseJsonValue()
        value = MakeString(ScanJsonString(false));
        MakeString return type: Handle<String>
        
        --- in old: ParseJsonString()
            Handle<String> ParseJsonString() {
                return ScanJsonString<false>();
            }
            



if there's string in property key, it will be handled by ScanJsonString



JsonParser<Char>::JsonParser(Isolate* isolate, Handle<String> source)
    : isolate_(isolate),
      hash_seed_(HashSeed(isolate)),
      object_constructor_(isolate_->object_function()),
      original_source_(source) 

what does
UpdatePointers
do


who initialize next_?

void advance() { ++cursor_; }